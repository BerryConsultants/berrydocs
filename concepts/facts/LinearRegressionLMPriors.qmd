---
title: "Linear Regression Multiple Imputation Model"
description: "A description of the Linear Regression multiple imputation model and a tool for helping specifying its prior."
execute:
  echo: false
filters:
  - shinylive
---

::: {.callout-tip}
## Jump to widget

[Click to jump straight to prior specification application.](LinearRegressionLMPriors.qmd#sec-priorSpecWidget)
:::

# Multiple Imputation in FACTS

When simulated subjects have multiple visits during the course of their
follow-up it is common that at the time of an analysis not all subjects
have complete known data. This can be because the subjects dropped out
(was lost to follow-up) or because the subject has not yet had time to
complete the visits that occur later in their follow-up window. Subjects
that are still in follow-up, but do not have final visit data are always
multiply imputed by FACTS through the specified longitudinal model.
Subjects who drop out may or may not be imputed based on user input in
"Handling of Missing Data Due to Dropouts" on the Design \> Dose
Response tab.

# The Linear Regression Multiple Imputation Model

The linear regression multiple imputation model is very simple. For each
early visit, it estimates an intercept and a slope that dictates how the
early visit data should be used to predict the final visit data. Only
the latest observed data point for a subject is used to impute their
final endpoint value, so if a subject can have 6 total visits and they
have known data at visits 1, 2, and 3, but missing data at visits 4, 5,
and 6, then the visit 3 data will be used to multiply impute the visit 6
data. No intermediate visits are imputed.

In the equation below, $Y_i\mid y_{it}$ is the final endpoint for
subject $i$ given an early value at visit $t$. Then,

$$
Y_i\mid y_{it} \sim \alpha_t+\beta_t y_{it}+\text{N}(0,\lambda_t^2 ).
$$

The parameter $\alpha_t$ is the intercept of the model for visit t,
and the parameter $\beta_t$ is a multiplicative modifier (slope) of the
response observed at visit $t$. So, to impute a value for $Y_i$, simply
take the early visit value, multiply it by $\beta_t$, add $\alpha_t$,
and then jitter a normal deviation with variance $\lambda_t^2$ around
that value.

## Prior Specification for the Linear Regression Multiple Imputation Model

The default setting of “Same priors across all model instances and
visits,” implies that each parameter $\alpha$, $\beta$, and $\lambda$
have the same prior for all visits $t$. Estimation of the posterior
distribution for these parameters is still done independently for each
model instance.

### Same prior for all visits and model instances

The one prior across all model instance are formulated as:
$$\alpha_t \sim \text{N}\left(\alpha_\mu, \alpha_{\sigma}^2\right)$$
$$\beta_t \sim \text{N}\left(\beta_\mu, \beta_{\sigma}^2\right)$$
$$\lambda_t^2 \sim \text{IG}\left(\frac{\lambda_n}{2}, \frac{\lambda_\mu^2 \lambda_n}{2}\right)$$

### Same prior for all model instances, different prior per visit

Since each visit will likely have a different estimated intercept and
slope needed to accurately impute the final endpoint, the above prior
formulation may not be desirable if specifying priors that are not
extremely diffuse – especially on the $\beta$ parameters. Instead,
selecting “Specify priors per visit across all model instances,” will
share the prior specification across all instances of the model, but
allows for different priors to be put on the parameters associated with
each visit. The user inputted prior parameters are now subscripted with
$t$ to denote the visit they correspond to. These priors apply to all
model instances:

$$\alpha_t \sim \text{N}\left(\alpha_{\mu_t}, \alpha_{\sigma_t}^2\right)$$
$$\beta_t \sim \text{N}\left(\beta_{\mu_t}, \beta_{\sigma_t}^2\right)$$
$$\lambda_t^2 \sim \text{IG}\left(\frac{\lambda_{n_t}}{2}, \frac{\lambda_{\mu_t}^2 \lambda_{n_t}}{2}\right)$$

### Different prior for all model instances and visits

It is also possible to specify priors “Per model instance and visit,” in
which every visit has separate priors, and those differing priors vary
across model instances. This is the most flexible prior specification
method. The user inputted prior parameters are now subscripted by both t
for visit and i for model instance.
$$\alpha_{ti} \sim \text{N}\left(\alpha_{\mu_{ti}}, \alpha_{\sigma_{ti}}^2\right)$$
$$\beta_{ti} \sim \text{N}\left(\beta_{\mu_{ti}}, \beta_{\sigma_{ti}}^2\right)$$
$$\lambda_{ti}^2 \sim \text{IG}\left(\frac{\lambda_{n_{ti}}}{2}, \frac{\lambda_{\mu_{ti}}^2 \lambda_{n_{ti}}}{2}\right)$$

## Choosing Values for Prior Parameters

A potential starting place for non-informative prior values would be:

$\mathbf \alpha$
:   mean of 0
:   standard deviation $\ge$ the largest expected response

$\beta$
:   mean of either 0 or $\frac{\text{final visit time}}{\text{early visit time}}$
:   standard deviation $\ge$ the largest expected ratio of final visit to first visit response

$\lambda$
:   mean of the expected final visit endpoint standard deviation ($\sigma$)
:   weight of 1. The variability of the prediction from the longitudinal model (based on an
observed intermediate response) should be less than the variability based solely on
the treatment allocation, thus this is a weakly pessimistic prior on the
effectiveness of the longitudinal model that should be quickly
overwhelmed by the data.

## Prior Specification Widget {#sec-priorSpecWidget}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 800
#| viewerWidth: 1200

library(shiny)
library(DT)
library(ggplot2)
library(htmltools)

alignCenter <- function(el) {
  htmltools::tagAppendAttributes(el,
                                 style="margin-left:auto;margin-right:auto;"
  )
}

sketch = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 2, ''),
      th(rowspan = 2, style = "border-right: solid 1px;",'Observed Visit Data'),
      th(colspan = 2, class="  dt-center", style = "border-right: solid 1px;",'\u3B1 priors'),
      th(colspan = 2, class="  dt-center", style = "border-right: solid 1px;",'\u3B2 priors'),
      th(colspan = 2, class="  dt-center", style = "border-right: solid 1px;",'\u3BB priors')
    ),
    tr(
      th("mean"),
      th(style = "border-right: solid 1px;", "SD"),
      th("mean"),
      th(style = "border-right: solid 1px;", "SD"),
      th("center"),
      th(style = "border-right: solid 1px;", "weight"),
    )
  )
))

ui <- fluidPage(
  tags$head(
    # Note the wrapping of the string in HTML()
    tags$style(HTML("
      .my_col_class {
         align-content: center;
      }")
    )
  ),
  
  titlePanel(h1("Linear Regression LM Priors", align = "center")),
  alignCenter(sliderInput("numVisits", "Number of visits:", 
                          min = 1, max = 20, value = 5, step = 1)),
  DTOutput("dataInputTable"),
  br(),
  titlePanel(h2("Plot a subject's prior predictive", align = "center")),
  fluidRow(
    #column(5, offset = 1, uiOutput("slider")),
    column(5, offset = 1, sliderInput(inputId = "lastVisitWithData", 
                                      label = "Last complete visit:", 
                                      min = 1, max = 5,
                                      value = 3, step = 1)),
    column(6, fluidRow(
      column(6, offset = 2, checkboxInput("fixAlpha", "Fix alpha at its mean?", value = FALSE, width = "100%")),
      column(6, offset = 2, checkboxInput("fixBeta", "Fix beta at its mean?", value = FALSE, width = "100%"))
    ))
  ),
  plotOutput("priorPredictive")
)

getLowerMedianUpper = function(earlyVisitVal, alpha = c(0,1), beta = c(0,1), lambda = c(1,1)) {
  distMeanFinal = c(alpha[1] + beta[1]*earlyVisitVal,
                    sqrt(alpha[2]^2 + beta[2]^2*earlyVisitVal^2))
  
  deviates = rnorm(10000)
  deviates = (deviates - mean(deviates))/(sd(deviates))

  samps = (deviates*distMeanFinal[2] + distMeanFinal[1]) + 1/rgamma(10000, lambda[2]/2, lambda[1]^2*lambda[2]/2)
  
  distValueFinal = c(mean(samps), sd(samps))
  
  return(list("meanFinal" = data.frame(lower = distMeanFinal[1] + qnorm(.025)*distMeanFinal[2],
                                       median = distMeanFinal[1],
                                       upper = distMeanFinal[1] + qnorm(0.975)*distMeanFinal[2]),
              "predictionFinal" = data.frame(lower = distValueFinal[1] + qnorm(.025)*distValueFinal[2],
                                             median = distValueFinal[1],
                                             upper = distValueFinal[1] + qnorm(0.975)*distValueFinal[2])))
}



server <- function(input, output, session) {
  
  df = data.frame(VisitResponse = rep(0, 5),
                  alphaPriorMean = 0,
                  alphaPriorSD = 10,
                  betaPriorMean = 0,
                  betaPriorSD = 10,
                  lambdaPriorCenter = 10, 
                  lambdaPriorWeight = 1)
  
  row.names(df) = paste("Visit", 1:5)
  
  ## Render DF to actually change
  output$dataInputTable = renderDT(datatable(df, 
                                             options = list(
                                               pageLength = 20,
                                               dom = "t",
                                               autoWidth = TRUE,
                                               columnDefs = list(list(className = 'dt-center', orderable = FALSE, width = '150px', targets = 0:7))
                                             ),
                                             container = sketch,
                                             rownames = TRUE,
                                             # escape = FALSE,
                                             selection = 'none',
                                             editable = list(target = "cell")
  ) |> formatStyle(c(1,3,5,7), `border-right` = "solid 1px") |>
       formatRound(1, digits = 4) |> formatRound(2:7, digits = 2)
  )
  
  ## Update from Conditional
  proxy = dataTableProxy('dataInputTable')
  
  observeEvent(input$dataInputTable_cell_edit, {
    info = input$dataInputTable_cell_edit
    str(info)
    i = info$row
    j = info$col
    v = info$value
    
    df <<- editData(df, info)
    
    replaceData(proxy, df) 
  })
  
  observe({
    nv = input$numVisits
    if(nv > nrow(df)) {
      tempd = df
      for(i in 1:(nv-nrow(df))) {
        tempd = rbind(tempd, setNames(data.frame(c(tempd[nrow(tempd),])), names(tempd)))
        rownames(tempd)[nrow(tempd)] = paste("Visit", nrow(tempd))
      }
      df <<- tempd
    } else if(nv < nrow(df)) {
      df <<- df[1:nv,]
    }
    replaceData(proxy, df) 
    
    updateSliderInput(session, "lastVisitWithData", max = nv, value = min(nv, input$lastVisitWithData))
  })
  
  output$priorPredictive = renderPlot({
    lvIndex = input$lastVisitWithData
    finalVisitIndex = input$numVisits
    tempDF = df
    dataToPlot = getLowerMedianUpper(tempDF[lvIndex,1],
                                     alpha = c(tempDF[lvIndex,2], ifelse(input$fixAlpha, 0, tempDF[lvIndex,3])),
                                     beta = c(tempDF[lvIndex,4], ifelse(input$fixBeta, 0, tempDF[lvIndex,5])),
                                     lambda = c(tempDF[lvIndex,6], tempDF[lvIndex,7]))
    
    tempDF$RowVisitIndex = 1:nrow(tempDF)
    tempDF$visitKnown = "included"
    tempDF$visitKnown[tempDF$RowVisitIndex > lvIndex] = "excluded"
    
    p1 = ggplot() + 
      geom_point(dat = tempDF, aes(x = RowVisitIndex, y = VisitResponse, color = visitKnown)) + 
      scale_color_manual(breaks = c("included", "excluded"), values = c("black", "gray70"), guide = "none") +
      coord_cartesian(xlim = c(1, finalVisitIndex)) + 
      xlab("Visit Index") + ylab("Response") +
      theme_bw() + 
      theme(text = element_text(size = 18))
    
    if(lvIndex < finalVisitIndex) {
      p1 = p1 + 
        geom_segment(data = dataToPlot[[2]], aes(x = finalVisitIndex, y = lower, yend = upper), color = "darkgreen", linewidth = 2.5) +
        annotate(geom = "point", x = finalVisitIndex, y = dataToPlot[[2]]$median, color = "darkgreen", size = 3, shape = 18) +
        annotate(geom = "ribbon", x = c(lvIndex, finalVisitIndex),
                 ymin = c(tempDF$VisitResponse[lvIndex], dataToPlot[[2]]$lower),
                 ymax = c(tempDF$VisitResponse[lvIndex], dataToPlot[[2]]$upper),
                 fill = "darkgreen", color = NA, alpha = .15) +
        geom_segment(data = dataToPlot[[1]], aes(x = finalVisitIndex, y = lower, yend = upper), color = "darkblue", linewidth = 1.5) +
        annotate(geom = "point", x = finalVisitIndex, y = dataToPlot[[1]]$median, color = "darkblue", size = 3, shape = 18) +
        annotate(geom = "ribbon", x = c(lvIndex, finalVisitIndex),
                 ymin = c(tempDF$VisitResponse[lvIndex], dataToPlot[[1]]$lower),
                 ymax = c(tempDF$VisitResponse[lvIndex], dataToPlot[[1]]$upper),
                 fill = "darkblue", color = NA, alpha = .4)
    } else {
      p1 = p1 + annotate(geom="text", label = "Final Visit Value Known",
                         alpha = .5, size = 10, x = (finalVisitIndex+1)/2, y = Inf, vjust = 1.3)
    }
    
    p1
  })
}

shinyApp(ui = ui, server = server)
```
